##计算机网络基础知识
<br>
####OSI七层模型和TCP/IP五层模型

        应用层
        表示层                  应用层
        会话层
        传输层                  传输层
        网络层                  网际层
        数据链路层              
        物理层                  网络接口层
        
        
        数据链路层：负责分配MAC地址
        网络层：负责对数据包进行路由选择和存储转发。网络层协议有：IP、ICMP、IGMP、ARP、RARP、OSPF
        传输层：是第一个端到端，即进程到进程的层次。传输层协议：TCP、UDP
        应用层：为操作系统或者网络应用程序提供访问网络服务的接口。应用层协议：FTP、HTTP、DNS、SNMP、NFS
        
        IP      网际协议
        ICMP    网际控制消息协议
        IGMP    因特网组管理协议
        ARP     地址解析协议
        RARP    反向地址解析协议
        OSPF    开放式最短路径优先
        
        TCP     控制传输协议
        UDP     用户数据报协议
        
        FTP     文件传输协议
        HTTP    超文本传输协议
        DNS     域名服务器协议
        SMTP    简单邮件传输协议
        NFS     网络文件系统协议


<br>    
####路由

        从用户的角度来看，路由是指将数据从一个用户终端通过网络节点（路由器、交换机等），发送到另一个用户节点的过程。理
        论上说，对于一个拥有多个节点的拓扑网络而言，路由是指在网络层将数据包从一个节点以最优路径发送到目标节点的方法。
        其核心包括：如何获得临近节点的信息，如何估计链路质量，如何寻址，如何构建网络拓扑结构等等。通过路由器之间的路由
        协议，可以实现两个网络节点之间的信息（包括网络域名，临近节点，链路质量等）的交换和散布，通过不断重复该过程，每
        个节点都会获得足够多关于所在网络的拓扑信息。当有数据包需要传送时，路由器再通过路由算法计算传递当前数据包的最优
        路径，并把数据包发送给下一个临近节点。许多路由算法基于图理论，实现了最小生成树，最短路径等等经典的拓扑算法。
        
        网络中，所谓的地址是指IP地址，IPV4规定利用32bits作为IP地址。但是随着网络设备的增多，IPV4已经不能满足人们的需求，
        故互联网逐渐向IPV6进行演进，IPV6利用128bits作为IP地址。
        
        直观而言，网络路由（network routing）的过程相当于传统意义上的邮包寄送，IP地址可以类比于邮政编码，路由器就相当于
        邮局，通过目的地邮政编码与邮局系统中的递送路径进行比较，由此确定下一步应该把当前包裹传递到哪里。


<br>
####TCP vs UDP

        1）TCP
        TCP是一种可靠的传输协议，即在网络正常的情况下，TCP协议能够保证接收端收到所有的数据，并且接收到的数据顺序与发送
        端一致。TCP通过在发送端给给每个数据包分配单调递增的 sequence number，以及在接收端发送ACK实现可靠传输。每个发送
        的数据端都包含序列号，都接收端收到数据包时，会发送ACK告诉接收端自己期待的下一个序列号是多少。例如，发送端分别发
        送了序列号为99、100、101、102的四个数据包，接收端收到数据包99后，会发送ACK 100，意味着接收端期待下一个数据包编
        号100。如果由于某些原因，数据包100没有到达接收端，但数据包101,、102到达了，那么接收端会继续发送ACK 100。当发送
        端发现当前发送的数据包编号超过了100，但接收端仍然期望收到100，那么发送端就会重新发送数据包100。如果接收端收到了
        重新发送的数据包100，那么接收端就会回复ACK 103，继续进行剩下的数据传输，并且把数据包99、100、101、102按顺序传递
        给上一层。
        
        流量控制（Flow Control）
        TCP使用了end-to-end flow control（端到端流量控制）以避免发送端发送数据过快导致接收端无法处理。TCP采用了滑动窗口
        实现流量控制。接收端通过ACK告诉发送端自己还能够接收多少数据，发送端不能发送超过该值的数据量。当接收端返回窗口大
        小为0时，发送端停止发送数据，直到窗口大小被更新。由于ACK 是由发送端发送的数据触发，可能接收端窗口已经打开，但是
        由于发送方已经停止发送，故接收端没有机会通过ACK告知发送端新的窗口大小，在这种情况下会造成死锁。在实际实现中，发
        送端会设置一个timer，如果timer到期，发送端会尝试发送小数据包，以触发接收端的ACK。
        
        拥塞控制（Congestion Control）
        为了控制传输速度防止堵塞网络，并且在网络容量允许的范围内尽可能多的传输数据，TCP 引入了拥塞控制，用以判断当前网络
        的符合，并且调整传输速率。TCP通常采用加法增大、乘法减小的算法，即如果按时收到对应的ACK，则下一次传输速率线性增加
        ，否则则视为发生了网络拥塞，下一次传输的比特数折半。
        所谓“按时“基于RTT（往返时延）：发送端会估计RTT，并且期望当数据包发送以后，在RTT时间内收到对应的ACK。
        
        2）UDP
        相比于TCP，UDP简单许多：连接建立时不需要经过类似于TCP的三次握手，只需要知道接收端的IP和端口，发送端就可以直接发
        送数据。同时，UDP也没有ACK、流量控制、拥塞控制，故UDP本身不能保证传输是可靠的。由于UDP本身只负责吧数据传输到目
        的地，故可扩展性比较强。有些应用可以实现基于UDP的特定算法，使得传输效率高于TCP。例如，当发生丢包时，TCP会重传该
        数据包，但该操作增加了传输延时。对于某些实时性要求较高的应用可能继续传输新的数据更为重要，故基于UDP的传输方式可
        以更好的满足该要求。
        
        
        通常而言，如果需要满足可靠性，有序接收，自适应宽带等要求，应该优先考虑TCP，因为其协议本身保证了这点。如果对实时
        性要求较高，或者应用需要特定的网络传输特性，则可以实现基于UDP的传输协议。往往，这样的协议需要实现拥塞控制、流量
        控制、重传等机制，故通常情况下可以直接采用TCP以减小开发成本。


<br>
####TCP三次握手

        SYN     同步序号，表示报文是一个连接请求或连接接受报文
        ACK     确认位，对接收到报文的确认
        
        1）客户端向服务器发送一个SYN J;
        
        2）服务器向客户端响应一个SYN K，并对 SYN J 进行确认 ACK J+1;
        
        3）客户端再向服务器发送一个确认 ACK K+1。

<br>
####TCP四次挥手

        FIN     终止位，表示发送方完成数据发送，用来释放一个连接
        
        1）某个应用程序首先调用close，我们称这一端执行主动关闭。这一端的TCP于是发送一个FIN分节，表示数据发送完毕；
        
        2）另一端接受FIN分节后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给接收端应用进程，因为FIN
        的接收意味着应用进程在相应的连接上再也接收不到额外数据；
        
        3）一段时间之后，接收到文件结束符的应用进程调用close关闭它的套接口。这导致它的TCP也发送一个FIN;
        
        4）接收到这个FIN的原发送端TCP（即执行主动关闭的那一端）对它进行确认。

<br>
####TCP为何采用三次握手，两次行吗？

        两次不行，采用三次握手是为了防止失效的连接请求报文段突然又传送到服务器，从而发生错误。当客户端发出的连接请求报
        文段由于某些原因没有及时到达服务器，而客户端等待一段时间后，又重新向服务器发送连接请求，且建立成功，顺序完成数
        据传输，那么第一次发送的连接请求报文段就称为失效的连接请求报文段。
        考虑这样一种特殊情况，客户端第一次发送的连接请求并没有丢失，而是因为网络问题导致延迟到达服务器，服务器以为是客
        户端又发起的新连接，于是服务器同意连接，并向客户端发回确认，但是此时客户端不予理会，服务器就一直等待客户端发送
        数据，导致服务器资源浪费。


<br>
####TCP为何采用四次挥手来释放连接？

        关闭连接时，当收到对方FIN报文通知时，它仅仅表示对方没有数据发送给你了，但未必表示你所有的数据都发送给对方了，所
        以你未必会马上关闭socket，也即你还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你没有数据发送给对方了，
        针对每个FIN报文，都需要一次ack报文，故需要四次挥手。


<br>
####在浏览器里输入URL地址回车后，发生了些什么？

        1）进行寻址：如果在浏览器的缓存中存有URL对应的IP，则直接查询其IP；否则，访问DNS（Domain Name System）进行寻址。
        
        2）DNS或者 URL cache 返回网页服务器的IP地址。
        
        3）浏览器与服务器通过三次握手建立TCP连接。由于是网页服务器，故浏览器连接到服务器的80端口。
        
        4）浏览器与服务器建立HTTP会话（session），接收来自服务器的HTTP数据。
        
        5）浏览器解析HTTP数据，在本地窗口内渲染并显示网页。
        
        6）当浏览器页面被关闭时，终止HTTP会话并关闭连接。
 
 
 
 <br>
 ####如果要设计一个可靠的UDP协议，该怎么做？

        所谓的可靠（reliable）都是指接收端能够将受到的数据情况反馈给发送端。由于可靠要求在接收端能够恢复数据包的顺序，
        故发送端每个数据包都需要sequence number。现在着重讨论反馈机制：
        
        1）最朴素的ACK方式：发送端每发送一个数据包都需要接收端返回ACK，一旦超时，发送端重新发送数据包，知道该数据包被
        接收端ACK。该方法效率不高，因为之后的所有数据包都被当前的数据包阻塞，并且每次返回ACK都增加了开销。
        
        2）Block/bit map ACK：发送端发送一批数据包，例如32个，编号0-31。接收端发回的ACK中用32bits（4 bytes）的bit map
        表示收到了哪些数据包，发送端再一次性重发所有未收到的数据包。该方法能够更加充分的利用宽带，在发送端一次性的传输
        更多的数据。但缺点是在发送端和接收端都需要更深的buffer，暂存正在传输的所有数据。
        
        3）ACK last packt：发送端可以在发送最后一个数据包时要求接收端反馈ACK，并重发丢失的数据包。这样做的好处是可以减
        少由ACK造成的数据开销，但需要通过buffer暂存数据。
        
        事实上，可以结合方法2和方法3，在每一批数据包的最后一个置位request ACK flag（请求ACK标志），要求接收端返回bit map
        ACK。更进一步的，可以根据丢包率及延迟，估计网络状况，动态的调整bit map的大小：在网络较好的情况下，用更大的bit map，
        即同时发送更多的数据。否则，减小发送数据量。事实上，这种对于网络状况的自适应也相当于实现了拥塞控制。


<br>
####对于实时视频会议的应用，选择TCP还是UDP？

        TCP的重传机制会增加延迟，所以不适用于当前场景。其次，视频音频编码本身可以容忍数据出错甚至数据丢失。因此，并不需
        要采用TCP进行可靠的数据传输。当某一视频帧出现丢包时，可以直接跳过这一帧或者继续播放上一帧。再次，一旦出现网络堵
        塞的情况，发送端应该主动丢弃一部分数据。原因是，即使这些视频帧发送到了接收端，也可能已经“过期”了，不会被解码显
        示。采用自己设计的UDP更便于实现对数据包的控制。然而，即使使用UDP，也需要实现TCP的某些模块：比如需要流量控制和拥
        塞控制来判断接收端的播放情况和网络情况，并且也需要反馈机制判断接收端的接收状况。尽管对于当前场景我们不需要ACK每
        个数据包，但是接收端可以反馈当前收到的最新完整视频帧的序号。这样，如果一旦发生丢包，发送端可以以接收端收到的最新
        完整视频帧为基础，压缩后继的视频。
        
        
        
