###经典面试题

<br>
####1.STL中vector实现原理？

        vector的数据安排以及操作方式，与array非常相似。两者的唯一区别在于空间的运用的灵活性。array是静态空间，一旦配置了
    就不能改变；要换个大（或小）一点的房子，可以，一切琐细都得由客户端自己来：首先配置一块新空间，然后将元素从旧址一一搬
    往新址，再把原来的空间释还给系统。vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。因此，
    vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必因为害怕空间不足而一开始要求一个大块头的array
    了，我们可以安心使用array，吃多少用多少。 
        vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率。一旦vector的旧有空间满载，如果客户端每新增
    一个元素，vector的内部只是扩充一个元素的空间，实为不智。因为所谓扩充空间（不论多大），一如稍早所说，是”  配置新空间/
    数据移动/释还旧空间  “的大工程，时间成本很高，应该加入某种未雨绸缪的考虑。
        另外，由于vector维护的是一个连续线性空间，所以vector支持随机存取。
        注意：vector动态增加大小时，并不是在原空间之后持续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大
    小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对vector
    的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了  。这是程序员易犯的一个错误，务需小心。
    
<br>
####2.给定N张扑克牌和一个随机函数，设计一个洗牌算法？

        void shuffle(int cards[], int n)
        {
            if (cards == NULL)
                return;
            
            srand(time(0)); // 利用系统时间改变系统的种子值，为rand函数提供不同的种子值
            
            for (int i = 0; i < n-1; ++i)
            {
                int index = i + rand()%(n-i); // 保证每次第i位的值不会涉及到第i位以前的值
                int tmp = cards[index];
                cards[index] = cards[i];
                cards[i] = tmp;
            }
        }
        
<br>
####3.100亿个整数，内存足够，如何找到中位数？内存不足，如何找到中位数？

    内存足够的情况：使用快速排序的思想进行，均摊复杂度为O(n)，算法思想如下
        ● 随机选取一个元素，将比它小的元素放在它的左边，比它大的元素放在右边；
        ● 如果它恰好在中位数的位置，那么它就是中位数，可以直接返回；
        ● 如果小于它的数超过一半，那么中位数一定在左半边，递归到左边处理；
        ● 否则，中位数一定在右半边，根据左半边的元素个数计算出中位数是右半边的第几大，然后递归到右半边处理。
    
    内存不足的情况：
    方法1：二分法
        思路：这些数都是整数，整数是有范围的，32位系统中就是[-2^32, 2^32-1]，可以对这个范围进行二分，然后找有多少个数
    大于mid，有多少个数小于mid，然后递归，和基于快速排序思想的第k大方法类似。
    方法2：分桶法
        思路：化大为小，把所有的数划分到各个小区间，把每个数映射到对应的区间里，对每个区间里数的个数进行计数，数一遍
    各个区间，看中位数落在哪个区间，若区间够小，使用基于内存的算法，否则继续划分。
    
<br>
####4.智能指针的原理？

        智能指针是一种资源管理类，通过对原始指针进行封装，在资源管理对象进行析构时对指针指向的内存进行释放，通常使用引
    用计数方式进行管理。

<br>
####5.实现一个单例模式的类，要求线程安全？

        [Singleton.cpp](./Singleton.cpp)

<br>
####6.如何定义一个只能在堆上（栈上）生成对象的类？

        在C++中，类的对象建立分为两种，一种是静态建立，如A a；另一种是动态建立，如A* ptr=new A；这两种方式是有区别的。
        静态建立一个类对象，是由编译器为对象在栈空间中分配内存，是通过直接移动栈顶指针，挪出适当的空间，然后在这片内存
    空间上调用构造函数形成一个栈对象。使用这种方法，直接调用类的构造函数。
        动态建立类对象，是使用new运算符将对象建立在堆空间中。这个过程分为两步，第一步是执行operator new()函数，在堆空
    间中搜索合适的内存并进行分配；第二步是调用构造函数构造对象，初始化这片内存空间。这种方法，间接调用类的构造函数。
    
    1）只能建立在堆上
        类对象只能建立在堆上，就是不能静态建立类对象，即不能直接调用类的构造函数。
        容易想到将构造函数设为私有。在构造函数私有之后，无法在类外部调用构造函数来构造类对象，只能使用new运算符来建立
    对象。然而，前面已经说过，new运算符的执行过程分为两步，C++提供new运算符的重载，其实是只允许重载operator new()函数，
    而operator()函数用于分配内存，无法提供构造功能。因此，这种方法不可以。
        当对象建立在栈上面时，是由编译器分配内存空间的，调用构造函数来构造栈对象。当对象使用完后，编译器会调用析构函
    数来释放栈对象所占的空间。编译器管理了对象的整个生命周期。如果编译器无法调用类的析构函数，情况会是怎样的呢？比如，
    类的析构函数是私有的，编译器无法调用析构函数来释放内存。所以，编译器在为类对象分配栈空间时，会先检查类的析构函数
    的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈
    空间上为类对象分配内存。
        因此，将析构函数设为私有，类对象就无法建立在栈上了。代码如下：
        
        class A {
        public:
            A() {}
            void destory() {delete this;}
        private:    
            ~A() {};
        };
        
        试着使用A a;来建立对象，编译报错，提示析构函数无法访问。这样就只能使用new操作符来建立对象，构造函数是公有的，
    可以直接调用。类中必须提供一个destory函数，来进行内存空间的释放。类对象使用完成后，必须调用destory函数。
        上述方法的一个缺点就是，无法解决继承问题。如果A作为其它类的基类，则析构函数通常要设为virtual，然后在子类重写，
    以实现多态。因此析构函数不能设为private。还好C++提供了第三种访问控制，protected。将析构函数设为protected可以有效
    解决这个问题，类外无法访问protected成员，子类则可以访问。
        另一个问题是，类的使用很不方便，使用new建立对象，却使用destory函数释放对象，而不是使用delete。（使用delete会
    报错，因为delete对象的指针，会调用对象的析构函数，而析构函数类外不可访问）这种使用方式比较怪异。为了统一，可以将
    构造函数设为protected，然后提供一个public的static函数来完成构造，这样不使用new，而是使用一个函数来构造，使用一个
    函数来析构。代码如下，类似于单例模式：
        
        class A {
        protected:
            A() {}
            ~A() {}
        public:
            static A* create() { return new A(); }
            void destory() { delete this; };
        };
    
        这样，调用create()函数在堆上创建类A对象，调用destory()函数释放内存。
        
    2）只能建立在栈上
        只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。将operator new()
    设为私有即可。代码如下：
        
        class A {
        private:
            void* operator new(size_t t) {} //注意函数的第一个参数和返回值都是固定的
            void operator delete(void* ptr) {} //重载了new就要重载delete
        public:
            A() {}
            ~A() {}
        };
    
<br>    
####7.简述C++虚函数作用及底层实现原理?
    
        要点是要答出虚函数表和虚函数表指针的作用。C++中虚函数使用虚函数表和虚函数表指针实现，虚函数表是一个类的虚函数
    的地址表，用于索引类本身以及父类的虚函数的地址，假如子类的虚函数重写了父类的虚函数，则对应在虚函数表中会把对应的
    虚函数替换为子类的虚函数的地址；虚函数表指针存在于每个对象中（通常出于效率考虑，会放在对象的开始地址处），它指向
    对象所在类的虚函数表的地址；在多继承环境下，会存在多个虚函数表指针，分别指向对应 不同基类的虚函数表。
    
    
    
    
    
    
    
