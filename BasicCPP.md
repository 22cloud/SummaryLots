##C/C++基础知识

####内存分区

        1.堆：由程序员手动分配和释放，完全不同于数据结构中的堆，分配方式类似链表。由malloc（C语言）或new（C++）来分配，free
        （C语言）和delete（C++）释放。若程序员不释放，程序结束时由系统释放。
        
        2.栈：由编译器自动分配和释放，存放函数的参数值、局部变量的值等。操作方式类似数据结构中的栈。
        
        3.全局（静态）存储区：存放全局变量和静态变量。包括DATA段（全局初始化区）与BSS段（全局未初始化区）。其中，初始化的全局
        变量和静态变量存放在DATA段，未初始化的全局变量和静态变量存放在BSS段。程序结束后有系统释放。
        其中BSS段的特点是：在程序执行之前BSS段会自动清0。所以，未初始化的全局变量和静态变量在程序执行之前就已经成0了。
        
        4.文字常量区：常量字符串就放在这里，程序结束后由系统释放。
        
        5.程序代码区：存放函数体的二进制代码。


<br>
####类和继承

        #define NAME_SIZE 50
        
        class Person {
                int id;                 // 所有成员默认为私有（private）
                char name[NAME_SIZE];
                
        public:
                void aboutMe()
                {
                        cout << "I am a person.";
                }
        };
        
        class Student {
        public:
                void aboutMe()
                {
                        cout << "I am a student.";
                }
        };
        
        Student* p = new Student();
        p->aboutMe();   // 打印“I am a student.”
        delete p;       // 务必释放之前分配的内存
        
        在C++中，所有数据成员和方法均默认为私有（private），可用关键字public修改其属性。


<br>
####构造函数和析构函数

        对象创建时会自动调用类的构造函数，如果没有定义构造函数，编译器会自动生成一个默认的构造函数（Default Constructor）。
        自定义构造函数：
                Person(int a) {
                        id  = a;
                }
                或者
                Person(int a) : id(a) { // 成员初值列
                        ...
                }
                在真正对象创建之前，且在构造函数余下代码调用前，数据成员id就会被赋值。在常量数据成员赋值时（只能赋值
                一次），这种写法特别适用。
        
        析构函数会在对象删除时执行清理工作。对象销毁时会自动调用析构函数。我们不会显示的调用析构函数，因此它不能带参数。
                ~Person() {
                        delete obj;     // 释放之前这个类里分配的内存
                }
        
        
        继承时构造函数与析构函数的调用顺序
                创建子类时，先调用基类的构造函数，只有这样子类才能在构造函数里使用基类的成员，然后再调用子类自身的构造
                函数。
                销毁对象时，子类先调用自身的析构函数，再调用基类的析构函数。基类的析构函数必须设置为虚拟的，而作为最终
                子类可以是虚拟也可以是非虚拟的。


<br>
####虚函数

        类的一个成员定义为一个虚函数的实际意义在于让C++知道该函数并无意义，它的作用只是为了让派生类进行函数重载保留位
        置。
        
        纯虚函数的定义方法就是在类的虚函数后面加上“ = 0 ”标记，类中一旦出现了纯虚函数的定义，那么此类为抽象类，不能实
        例化。为什么不能实例化？因为抽象类中的纯虚函数没有具体的实现，所以没办法实例化。
        
        class Person {
                int id;
                char name[NAME_SIZE];
        public:
                virtual aboutMe() {
                        cout << "I am a person.";
                }
                
                virtual bool addCourse(string s) = 0;
        };
        
        class Student : public Person {
        public:
                void aboutMe {
                        cout << "I am a Student.";
                }
                
                bool addCourse(string s) {
                        cout << "Added Course " << s << "to student." << endl;
                        return true;
                }
        };
        
        Person* p = new Student();
        p->aboutMe();   // 打印“I am a student.”
        p->addCourse("History");
        delete p;
        
        虚析构函数：
                class Person {
                public:
                        ~Person() {
                                cout << "Deleteing a person." << endl;
                        }
                };
                
                class Student : public Person {
                public:
                        ~Student() {
                                cout << "Deleting a student." << endl;
                        }
                };
                
                Person* p = new Student();
                delete p;
                
                打印输出如下：
                Deleting a student.
                Deleting a person.
        
        虚函数工作原理：
                虚函数需要虚函数表（Virtual Table）才能实现。如果一个类有函数声明称虚拟的，就会生成一个vtable，存放
                这个类的虚函数地址。此外，编译器还会在类里加入隐藏的vptr变量（虚函数指针）。若子类没有覆写虚函数，该
                子类的vtable就会存放父类的函数地址。调用这个虚函数时，就会通过vtable解析函数的地址。
                在C++里，动态绑定就是通过vtable机制实现的。


<br>
####构造函数为什么不能为虚函数

        假如有如下的代码：
        class A
        {
                A() {}
        };
        
        class B : public A
        {
                B():A() {}
        };
        
        则构造B的对象时：
        1）根据继承的性质，构造函数执行顺序是：A()B()
        2）根据虚函数的性质，如果A的构造函数为虚函数，且B类也给出了构造函数，则应该只执行B类的构造函数，不再执行A类的
        构造函数。这样A就不能构造了。
        3）这样1和2就发生了矛盾。
        
        另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作。


<br>
####深拷贝和浅拷贝

        浅拷贝会将对象的所有成员的值拷贝到另一个对象里。除了拷贝所有对象的值，深拷贝还会进一步拷贝所有指针对象。
        
        struct Test {
                char* ptr;
        };
        
        void shallow_copy(Test& src, Test& dest) {
                dest.ptr = src.ptr;
        }
        
        void deep_copy(Test& src, Test& dest) {
                dest.ptr = (char *)malloc(strlen(src.ptr) + 1);
                strcpy(dest.ptr, src.ptr);
        }
        
        shallow_copy可能会导致大量编程运行时错误，尤其是在对象创建和销毁时。使用浅拷贝是必须非常小心，只有当开发人员
        真正知道自己在做些什么的时方可选用浅拷贝。多数情况下，使用浅拷贝是为了传递一块复杂的结构信息，但又不想真的复
        制一份数据。使用浅拷贝时，销毁对象必须非常小心。
        在实际开发中，浅拷贝很少使用。大部分情况都应该使用深拷贝。


<br>
####指针和引用

        1）引用必须被初始化，指针不必。
        2）引用初始化以后不能被改变，指针可以改变所指的对象。
        3）不存在指向空值的引用，但是存在指向空值的指针。
        
        指针的大小随着计算机体系结构不同而不同：在32位机器上为32位，在64位机器上为64位。
        
        
        


<br>
####static

        不考虑类，static的作用主要有3条：
        1.隐藏。所有未加static前缀的全局变量和函数都具有全局可见性。如果加了static，就会对其他源文件隐藏。
        2.默认初始化为0，包括未初始化的全局静态变量与局部静态变量。其实未初始化的全局变量也具备这一属性，因为未初始化的
        全局变量与未初始化的静态变量是存储在同一块区域内的（BBS段）
        3.保持局部变量内容的持久。静态局部变量的生存期为整个源程序，作用域仍与局部变量相同。
        
        类中static的作用：
        C++重用了static这个关键字，并赋予它与前面不同的含义：表示属于一个类而不是属于此类的任何特定对象的变量和函数。
        1.静态数据成员
                static数据成员独立于该类的任意对象而存在。当某个类的实例修改了该静态成员变量，其修改值为该类的其他所有
                实例可见。static数据成员必须在类定义体的外部定义（正好一次）。
        2.静态成员函数
                1）静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数。静态成员函数不能访问非
                静态数据成员和非静态成员函数，非静态成员函数可以任意的访问静态数据成员和静态成员函数。
                
                2）由于没有this指针的额外开销，因此静态成员函数与类的非静态成员函数相比速度上会有少许提升。


<br>
####C++中const的作用

        const修饰的内容不可改变，被const修饰的（数据成员，参数，返回值，成员函数）都受到强制保护，可以预防意外的变动，能
        提高程序的健壮性。
        
      
<br>
####C++中，static、const以及static const成员变量的初始化

        在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文
        件中初始化。
        
        在C++中，const成员也不能在类的定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数。const数据成员只
        在某个对象生存期内是常量，而对整个类而言却是可变的。因为类可以创建多个对象，不同的对象其const数据成员的值可以不
        同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。
        
        要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者static const。
        
        class Test {
        public:
                Test()::a(0) {}
                enum {size1 = 100, size2 = 200};
        private:
                const int a;    // 只能在构造函数初始化列表中初始化
                static int b;   // 在类的实现文件中定义并初始化
                const static int c;     // 与static const int c;相同，c为整型，故也可在此处初始化，但仍需在定义体外进行
                                        // 定义，注意c为非整型时，不能在此处初始化，整型包括char、short、int、long
        };
        
        int Test::b = 0;        // static成员变量不能在构造函数初始化列表中初始化，因为它不属于某个对象
        const int Test::c = 0;  // 给const static成员变量赋值时，不需要加static修饰符，但要加const


<br>
####在C++_中使用const比使用#define有更多的优点。

        1）const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行安全类型检查。而对后者只进行字符替换，没有类
        型安全检查，并且在字符替换时可能会产生意想不到的错误。
        
        2）使用常量可能比使用#define导致产生更小的目标代码，这是因为预处理器“盲目地将宏名称BUFSIZE替换为其代替的值100”
        可能导致目标代码出现多份100的备份，但常量就不会出现这种情况。
        
        3）const还可以执行常量折叠（将常量表达式计算求值，并用求得的值来替换表达式），即编译器在进行编译时可以通过必要
        的计算把一个复杂的常量表达式缩减成简单的。


<br>
####二维数组

        声明与初始化：
        int ia[3][4] = {
                { 0, 1, 2, 3},
                { 4, 5, 6, 7},
                { 8, 9, 10, 11}
        };
        
        int ia[3][4] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
        
        动态声明a[m][n]：
        int **a = new int* [m];
        for (int i = 0; i < m; i++)
                a[i] = new int[n];
                
        for (int i = 0; i  < m; i++)
                delete[] a[i];
        delete[] a;


<br>
####malloc/free与new/delete

        malloc/free是C/C++语言的标准库函数，new/delete是C++操作符。
        对于用户自定义的对象而言，用malloc/free无法满足动态管理对象的要求。对象在创建的同时要自动执行构造函数，对象在
        销毁之前要自动执行析构函数。malloc仅仅分配内存，free仅仅回收内存，并不执行构造函数和析构函数。由于malloc/free
        是库函数而不是操作符，不在编译器控制的权限范围内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此，
        C++需要一个能完成动态内存分配和初始化的运算符new，以及一个能完成清理与释放内存工作的运算符delete。


<br>
####extern关键字

        1）在C语言中，extern用在变量或函数声明前，用来说明“此变量/函数在别处定义，要在此处引用”。
        
        2）在C++中，extern还有另外一种作用，用于指示C或者C++的调用规范。比如在C++中调用C库函数，就需要在C++程序中用
        extern "C" 声明要引用的函数。
        C++语言在编译的时候为了解决函数的多态问题，会将函数名和参数联合起来生成一个中间的函数名称，而C语言则不会，因此
        会造成链接时找不到对应函数的情况，此时C函数就需要用extern "C" 进行链接指定，这告诉编译器，请保持我的名称，不要
        给我生成用于链接的中间函数名。


<br>
####显示类型转换

        1）dynamic_cast
                主要用于执行“安全向下转型（safe downcasting）”。也就是说，要确定一个对象是否是一个继承体系中的一个特定
                类型。它是唯一不能用旧风格语法执行的强制转换，也是唯一可能有重大运行时代价的强制转换。
                
        2）static_cast
                可以用于强制隐型转换（例如，non-const对象转型为const对象，int转型为double等）
                还可以用于很多这样的转换的反向转换（例如，void*指针转型为有类型的指针，基类指针转型为派生类指针）
                不能将const对象转型为non_const对象（只有const_cast）能做到
        
        3）const_cast
                用于强制消除对象的常量性。它是唯一能做到这一点的C++风格的强制转型。
        
        4）reinterpret_cast
                用于底层的强制转换，导致实现依赖（不可移植）的结果。例如，将一个指针转型为一个整数。这样的转型在底层代
                码以外应该极为罕见。


<br>
####C++是不是类型安全的

        不是，两个不同类型的指针之间可以强制转换（用reinterpret_cast）。


<br>
####链表和数组

        数组将元素存放在连续的地址中，链表将数据存放在内存中的任意位置。这使得链表有巨大的扩展自己的灵活性，因为内存总
        是分散的。这种情况总是可能的：你无法创建一个数组来存放一百万个整数，但可以用链表来存放，因为空间总是存在的，只
        是不连续。其他的不同都源于这项事实。例如，在数组中，如果你知道下标，可以用O(1)的时间得到一个元素，但在链表中要
        花O(n)的时间。


<br>
####面向对象程序设计三大特点

        1）封装
                封装机制将数据和代码捆绑到一起，避免了外界的干扰和不确定性。一个对象就是一个封装了数据和操作这些数据的代
                码的逻辑实体。通过访问权限这种控制方式，对象对内部数据提供了不同级别的保护。
                
        2）继承
                继承可以让某个类型的对象获得另一个类型的对象的属性和方法。
                
        3）多态
                实现不同类的对象，对用一个方法的调用，产生不同的响应方式。


<br>
####派生类

        1）共有继承（public）
        对派生类来说
                基类的公共成员和保护成员可见：作为派生类的成员时，它们都保持原有的状态（公有和保护）
                基类的私有成员不可见：基类的私有成员仍然是私有的，且派生类不可访问基类中的私有成员。
        
        对派生类对象来说
                基类的公有成员时可见的，其他成员是不可见的。
                所以在公有继承时，派生类的对象可以访问基类中的公有成员；派生类的成员函数可以访问基类中的公有成员和保护成员。
        
        2）私有继承（private）
        对派生类来说
                基类的公共成员和保护成员可见：基类的公有成员和保护成员都作为派生类的私有成员，并且不能被这个派生类的子类
                访问。
                基类的私有成员不可见：派生类不可访问基类的私有成员。
        
        对派生类的对象来说
                基类的所有成员都是不可见的。
                所以，在私有继承时，基类的成员只能由直接派生类访问，而无法再往下继承。
        
        3）保护继承（protected）
        对派生类来说
                基类的公有成员和保护成员可见：基类的公有成员和保护成员都作为派生类的保护成员，并且不能被这个派生类的子类
                所访问。
                基类的私有成员不可见：派生类不可访问基类的私有成员。
        对派生类对象来说
                基类的所有成员都不可见。
                所以，在保护继承时，基类的成员只能由直接派生类访问，而无法再往下继续。
        
        
        在无继承的类中，protected和private控制符没有差别。在继承中，基类的private对所有外界都屏蔽（包括自己的派生类），基
        类的protected控制符对应用程序是屏蔽的，但对其派生类是可访问的。


<br>
####友元函数

        为什么要使用友元函数？
                在实现类之间的数据共享时，减少系统开销，提高效率。如果类A中的函数要访问类B中的成员，那么类A中的函数要是类
                B的友元函数。即允许外面的类或函数访问类的私有变量和保护变量，从而使两个类共享同一个函数。
        
        使用友元函数的优缺点？
                优点：能够提高效率，表达简单，清晰
                缺点：友元函数破坏了封装机制


<br>
####编码

        1）反码 = 除符号位按位取反的值
        2）补码 = 反码 + 1
        3）对补码求反加1即得原码；对原码求反加1即得补码
        
        负数在内存中用其补码表示。所以，对于char类型来说，10000000为-128,10000001为-127；11111111为-1。
        例如：
                char a = 256;
                int d = a;
                cout << d << endl;      // 输出0
        若把256改为255，则输出-1


<br>
####sizeof和strlen的区别

        1）sizeof是一个操作符，strlen是库函数。
        2）sizeof的参数可以是数据的类型，也可以是变量，而strlen只能以结尾为'\0'的字符串作参数。
        3）编译器在编译时就计算出了sizeof的结果，而strlen函数必须运行时才能计算出来，并且sizeof计算的数据类型占内存的大
        小，而strlen计算的是字符串的实际长度。
        4）数组做sizeof的参数不退化，传递给strlen就退化成指针了。


<br>
####C++空类有哪些成员函数

        1）缺省构造函数
        2）缺省复制构造函数
        3）缺省析构函数
        4）缺省赋值运算符
        5）缺省取址运算符
        6）缺省取址运算符const
        
        只有当实际使用这些函数时，编译器才会去定义它们。
        

<br>
####为CMyString类中各函数补齐函数体

        class MyString
        {
        public:
                CMyString(const char* pData = NULL);
                CMyString(const CMyString& other);
                ~CMyString();
                CMyString& CMyString::operator =(const CMyString &str);
                
        private:
                char* m_pData;
        }
        
        CMyString::CMyString(const char* pData)
        {
                if (pData == NULL)
                {
                        m_pData = new char[1];
                        *m_pData = '\0';
                }
                else
                {
                        int length = strlen(pData);
                        m_pData = new char[length+1];
                        strcpy(m_pData, pData);
                }
        }
        
        CMyString::CMyString(const CMyString &other)
        {
                int length = strlen(other.m_pData);
                m_pData = new char[length+1];
                strcpy(m_pData, other.m_pData);
        }
        
        CMyString::~CMyString()
        {
                delete[] m_pData;
        }
        
        CMyString& CMyString::operator =(const CMyString& str)
        {
                if (this == &str)
                        return *this;
                
                delete[] m_pData;
                m_pData = NULL;
                m_pData = new char[strlen(str.m_pData) + 1];
                strcpy(m_pData, str.m_pData);
                retrun *this;
        }
        
        定义一个赋值运算符函数需要注意以下几点：
        1）是否把返回值的类型声明为该类型的引用，并在函数结束前返回实例自身的引用（*this）。只有返回一个引用，才可以允
        许连续赋值。否则如果函数的返回值是void，应用该赋值运算符将不能做连续赋值。
        
        2）是否把传入的参数的类型声明为常量引用。如果传入的参数不是引用而是实例，那么从形参到实参会调用一次复制构造函
        数。把参数声明为引用可以避免这样的无谓消耗，能提高代码的效率。同时，我们在复制运算符函数内不会改变传入的实例的
        状态，因此应该为传入的引用参数加上const关键字。
        
        3）是否释放实例自身已有的内存。如果我们忘记在分配新内存之前释放自身已有的内存空间，程序将出现内存泄露。
        
        4）是否判断传入的参数和当前的实例（*this）是不是同一个实例。如果是同一个，则不进行赋值操作，直接返回。如果事先
        不判断就进行赋值，那么在释放实例自身内存的时候就会导致严重的问题：当*this和传入的参数是同一个实例时，那么一旦释
        放自身的内存，传入的参数的内存也同时被释放了，因此再也找不到需要赋值的内容了。


<br>
####复制构造函数与赋值运算符函数的区别

        1)复制构造函数生成新的类对象，赋值运算符则是在一个现存的对象赋予新的值时被调用。
        2）赋值构造函数不返回任何值，void都没有。赋值运算符有返回值。
        
        当类中有指针类型的成员变量时，一定要重写复制构造函数和赋值运算符，不要使用默认的。


<br>
####对面向对象的认识

        面向对象可以理解为对待每一个问题，首先要确定这个问题由几部分组成，而每一个部分其实就是一个对象，然后再分别设计
        这些对象，最后的到整个程序。传统的程序设计多是基于功能的思想来进行考虑和设计的，而面向对象的程序设计则是基于对
        象的角度来考虑问题。这样做能够使得程序更加简洁、清晰。


<br>
####strcpy和memcpy的区别

        1）复制的内容不同。strcpy只能复制字符串，而memcpy可以复制任意内容。
        2）复制的方法不同。strcpy不需要指定长度，它遇到被复制字符串的结束符'\0'时才结束。memcpy则是根据第3个参数决定复
        制的长度。
        3）用途不同。通常在复制字符串时用strcpy，而需要复制其他类型数据时则一般用memcpy。
